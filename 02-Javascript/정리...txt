삼항연산자

const age2 = 22;
// let 변수 = 조건식 ? 값1 : 값2;
const type2 = age2 >= 20 ? "성인" : "청소년";
console.log("당신은 %s입니다.", type2);
-------------------------------------------------------------------------------------------------
// -> k를 2~9 사이로 제한한 if 문
if (k > 1 && k < 10) {
-------------------------------------------------------------------------------------------------
switch 문
    : 조건에 맞는 case 블록부터 break 키워드를 만날 때 까지 실행
     마지막의 default는 모든 케이스를 충족하지 않을 경우 실행되고, 필요 없다면 생략

switch (변수) {
    case 1:
        ... 실행할 명령 ...
        break;
    case 2:
        ... 실행할 명령 ...
        break;
    case n:
        ... 실행할 명령 ...
        break;
    default:
        ... 실행할 명령 ...
        break;
}
-------------------------------------------------------------------------------------------------
while문
    : {} 안에서 선언되는 변수나 상수는 그 블록 안에서만 유효
초기식
while (조건식) {
    ... 반복적으로 수행될 구문 ...
    증감식
}
-------------------------------------------------------------------------------------------------
For문

for (초기식; 조건식; 증감식) {
    ...
}
// 부모의 반복문은 행(가로)을 담당, 자식의 반복문은 열(세로)을 담당
// 반복문 안에서의 조건문은 주로 반복문의 초기식 변수(i)에 대한 경우의 수를 판별함.

// - <총 합>, <총점> 을 구할 때 바깥에서 초기화를 시킴--> let sum = 0;
// - 누적된 곱셈에 대한 초기값은 1부터 시작 --> let bit = 1;

// for...of 는 배열의 반복에서 사용되고,	          -->      var arr = [1, 2, 3];
// for...in 은 객체의 반복에서 사용된다.           -->      var obj = {
   (일치하는 값은 아니고 해당 배열의 index가 출력)                  a: 1,
                                                                                 b: 2,
                                                                                 c: 3
                                                                             };
-------------------------------------------------------------------------------------------------
글자 사이에 콤마 넣기

// 1~9까지의 숫자 사이사이에 콤마를 넣어 한 문장으로 결합
console.group("글자 사이에 콤마(,) 넣기");
    let str = "";

    for (let i = 1; i < 10; i++) {
        str += i;

        if (i + 1 < 10) {
            str += ",";
        }
    }
    console.log(str);
console.groupEnd();
--------------------------------------------------------------------------------------------------
배열

// 5 라는 값을 원소로 갖는 한 칸으로 구성된 배열 만들기
let myArr3 = [5];
console.log(myArr3);    // [ 5 ]

// 값이 존재하지 않는 5개의 빈 칸을 갖는 배열 만들기
let myArr4 = new Array(5);
console.log(myArr4);    // [ <5 empty items> ]

****************************************************************************

☞ 배열의 최대값 구하기 ☞ 06-배열>06.최대값.js

// 원소값을 무작위로 갖는 배열
const data = [5, 2, 7, 9, 2];

// 비교를 위해 배열의 첫 번째 원소를 복사
let max = data[0];

// 1번째 이후 원소부터 마지막 원소까지 반복
for (let i = 1; i < data.length; i++) {
    console.log("max=%d, data[%d] = %d", max, i, data[i]);

    // max가 data의 i번째보다 작다면 i번째 원소를 max에 복사
    // 비교식의 부등호 방향만 반대로 지정하면 최소값을 구할 수 있다.
    if (max < data[i]) {
        console.log(">> max에 " + data[i] + "를 복사");
        max = data[i];
    }
}

console.log("---------");
console.log("최대값 = " + max); // 최대값 = 9

****************************************************************************

☞ 반복 횟수를 구하기 위한 연산 ☞ 06-배열>07.역순배치.js

 1. 원소가 5개 일 경우 반복 횟수 : 2회
     - 5/2를 연산한다. 연산 결과를 parseInt() 명령을 통해 나머지를 버릴 수 있다. 2나머지5 -> 2
 2. 원소가 6개 일 경우 반복 횟수 : 3회
     - 6/2를 연산한다

=> 즉, 배열의 길이/2 만큼 반복 처리

[반대쪽 위치의 원소 구하기]
=> 배열의길이-i-1

****************************************************************************

☞ 배열 순서대로 정렬하기 ☞ 06-배열>08.정렬.js

// 부등호 방향 ">" : 오름차순(순차정렬)
// 부등호 방향 "<" : 내림차순(역순정렬)

****************************************************************************
--------------------------------------------------------------------------------------------------
함수

*** 값이 전달되지 않은 파라미터는 undefined로 식별된다.

function 함수이름(파라미터1=기본값1, 파라미터1=기본값2, ..., 파라미터n=기본값n) {
    ...
}
--------------------------------------------------------------------------------------------------
리턴

function 함수이름(파라미터1, 파라미터2, ... 파라미터n) {
    ... 파라미터를 활용한 프로그램 구문 ...
    return 돌려줄_값;
}
--------------------------------------------------------------------------------------------------
익명함수
    : 다른 변수에 참조시킬 목적으로 함수를 정의할 때 부터 이름 없이 정의하는 형태.
    함수가 대입된 변수는 그 자체가 함수의 역할을 한다.

const 변수 = function(...) {
   ...
};
--------------------------------------------------------------------------------------------------
콜백함수
    : 파라미터로 전달되기 위해 사용되는 함수.

--------------------------------------------------------------------------------------------------
재귀함수
    : 함수가 처리로직 내부에서 자기 자신을 호출하는 형태.
    재귀호출은 마지막에 종료 조건을 명시하지 않는다면 무한루프에 빠지게 된다. 
    그러므로 재귀호출을 구현할 때 가장 먼저 처리해야 할 것은 "종료조건을 명시" 하는 것이다.

function 함수이름(파라미터1, 파라미터2, ... 파라미터n) {
    if (종료조건) {
        return 값;
    } else {
        // 자기 스스로를 호출한다.
        함수이름(파라미터1, 파라미터2, ... 파라미터n);
    }
}

팩토리얼 구하기
팩토리얼의 수식을 분석해 본다면 다음과 같이 정의할 수 있다.

f(x)=x∗f(x−1)(단,x가1이하인경우1)
--------------------------------------------------------------------------------------------------
화살표 함수 (arrow function)
    : function 키워드가 삭제되고
    파라미터를 전달하기 위한 소괄호()와 블록을 구성하기 위한 중괄호{} 사이에 => 기호가 추가된다.

const 변수 = (파라미터1, 파라미터2, ... 파라미터n) => {
    ... 처리로직 ...
};

↓↓↓↓리턴을 위한 구문 한 줄만 포함하는 익명함수↓↓↓
const 변수 = function(파라미터1, 파라미터2, ... 파라미터n) {
    return 리턴값;
};
↓↓↓↓↓↓위와 같은 형태를 화살표 함수로 변경↓↓↓↓↓↓
const 변수 = (파라미터1, 파라미터2, ... 파라미터n) => 리턴값;

☞ 피보나치수열에서 10번째 항목 ☞ 08-함수>14-재귀함수-피보나치수.js
0 1 1 2 3 5 8 13 21 34 55 . . .
f(n) = f(n-1) + f(n-2)  // 피보나치수의 정의
--------------------------------------------------------------------------------------------------
생성자 함수
function helloworld() {
    ...
}
const h = new helloworld(); // <=== 같이 사용되는 함수를 **생성자(Constructor)**한다.

    1) 함수를 new 연산자를 사용하여 호출하는 경우
        이 함수는 Javascript에 의해 객체를 만들기 위한 함수로 분류된다.
        (화살표 함수 형식은 생성자로 사용할 수 없다.)

    2) 생성자에 멤버변수 포함시키기
        생성자 함수 안에서 this 키워드를 통해 정의한 변수는 객체의 멤버변수 역할
        * this 키워드 >> 현재 클래스나 부모로부터 상속 받은 자원을 가리키는 예약어

        function helloworld() {
            this.x = 5;
            this.y = 10;
        }
        const h = new helloworld();
        const z = h.x + h.y; // 5 + 10

****************************************************************************
1 - prototype 속성

생성자함수.prototype.메서드이름 = function(파라미터1, 파라미터2, ... 파라미터n) {
    ...
    return 돌려줄_값;
}

// 메서드 호출하기
const 객체이름 = new 생성자함수();
const k = 객체이름.메서드이름();

****************************************************************************
 getter, setter
--------------------------------------------------------------------------------------------------
class
    : 객체의 설계도 역할을 하는 프로그램 소스

#01. 객체 (Object)
프로그래밍에서의 의미 : 프로그램에서 표현하고자 하는 기능을 묶기 위한 단위
- 객체를 이루는 것은 데이터와 기능이다.
- 데이터는 변수로 표현된다.
    ㄴ> 객체 안에 포함된 변수를 멤버변수 혹은 프로퍼티라 한다.
- 기능은 메서드(=함수)로 표현된다.

***클래스의 가장 기본적인 코드 형식
    class 클래스이름 {
        // 생성자 --> 멤버변수 선언 및 기타 초기화
        // getter, setter
        // 메서드
    }

***클래스를 통한 객체 생성하기
    new 예약어를 사용한다.
    var|let|const 변수이름 = new 클래스이름();

    객체.멤버변수 = 값;
    객체.메서드();

***메서드 오버라이드(Override) : 숨겨진 부모의 기능을 수정하는 개념
***super 키워드 >> 자식에게 숨겨진 부모의 원래 기능을 호출하고자 하는 경우
--------------------------------------------------------------------------------------------------
 * parseFloat(value) : 주어진 값에서 변환한 부동소수점 수(실수)를 리턴 (변환할 수 없으면 NaN을 리턴)
 * parseInt(value, int) : 첫 번째 피라미터를 10진 정수값으로 변환한다.
    // 10진법: 0 1 2 3 4 5 6 7 8  9  10 11 12 13 14 15 16 17 18 19 19 19 -> ex) 12
    // 16진법: 0 1 2 3 4 5 6 7 8  9   A  B  C  D  E  F 10 11 12 13 14 15 -> ex) 0x12
    //  8진법: 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 -> ex) 0o12

 * setTimeout(func, int) : 딜레이
 * setInterval(func, int) : 타이머